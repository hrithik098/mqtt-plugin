"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var coordinate_1 = require("../../util/coordinate");
var polar_1 = tslib_1.__importDefault(require("./polar"));
/** label text和line距离 4px */
var MARGIN = 4;
function getEndPoint(center, angle, r) {
    return {
        x: center.x + r * Math.cos(angle),
        y: center.y + r * Math.sin(angle),
    };
}
/**
 * 饼图 label
 */
var PieLabel = /** @class */ (function (_super) {
    tslib_1.__extends(PieLabel, _super);
    function PieLabel(geometry) {
        var _this = _super.call(this, geometry) || this;
        _this.defaultLabelCfg = util_1.get(geometry.theme, 'pieLabels', {});
        return _this;
    }
    PieLabel.prototype.getDefaultOffset = function (offset) {
        return offset || 0;
    };
    // 连接线
    PieLabel.prototype.lineToLabel = function (label) {
        var coordinate = this.coordinate;
        // @ts-ignore
        var r = coordinate.getRadius();
        var distance = label.offset;
        var angle = label.angle;
        var center = coordinate.getCenter();
        // 贴近圆周
        var start = getEndPoint(center, angle, r);
        var inner = getEndPoint(center, angle, r + distance / 2);
        var end = {
            x: label.x - Math.cos(angle) * MARGIN,
            y: label.y - Math.sin(angle) * MARGIN,
        };
        if (!util_1.isObject(label.labelLine)) {
            // labelLine: true
            label.labelLine = {};
        }
        label.labelLine.path = ["M " + start.x, start.y + " Q" + inner.x, inner.y + " " + end.x, end.y].join(',');
    };
    PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {
        var rotate;
        if (offset < 0) {
            rotate = angle;
            if (rotate > Math.PI / 2) {
                rotate = rotate - Math.PI;
            }
            if (rotate < -Math.PI / 2) {
                rotate = rotate + Math.PI;
            }
        }
        return rotate;
    };
    PieLabel.prototype.getLabelAlign = function (point) {
        var coordinate = this.coordinate;
        var center = coordinate.getCenter();
        var align;
        if (point.angle <= Math.PI / 2 && point.x >= center.x) {
            align = 'left';
        }
        else {
            align = 'right';
        }
        var offset = this.getDefaultOffset(point.offset);
        if (offset <= 0) {
            if (align === 'right') {
                align = 'left';
            }
            else {
                align = 'right';
            }
        }
        return align;
    };
    PieLabel.prototype.getArcPoint = function (point) {
        return point;
    };
    PieLabel.prototype.getPointAngle = function (point) {
        var coordinate = this.coordinate;
        var startPoint = {
            x: util_1.isArray(point.x) ? point.x[0] : point.x,
            y: point.y[0],
        };
        var endPoint = {
            x: util_1.isArray(point.x) ? point.x[1] : point.x,
            y: point.y[1],
        };
        var angle;
        var startAngle = coordinate_1.getPointAngle(coordinate, startPoint);
        if (point.points && point.points[0].y === point.points[1].y) {
            angle = startAngle;
        }
        else {
            var endAngle = coordinate_1.getPointAngle(coordinate, endPoint);
            if (startAngle >= endAngle) {
                // 100% pie slice
                endAngle = endAngle + Math.PI * 2;
            }
            angle = startAngle + (endAngle - startAngle) / 2;
        }
        return angle;
    };
    PieLabel.prototype.getCirclePoint = function (angle, offset, p) {
        var coordinate = this.coordinate;
        var center = coordinate.getCenter();
        // @ts-ignore
        var r = coordinate.getRadius() + offset;
        return tslib_1.__assign(tslib_1.__assign({}, getEndPoint(center, angle, r)), { angle: angle,
            r: r });
    };
    return PieLabel;
}(polar_1.default));
exports.default = PieLabel;
//# sourceMappingURL=pie.js.map