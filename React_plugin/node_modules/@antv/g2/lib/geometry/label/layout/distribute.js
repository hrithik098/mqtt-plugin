"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@antv/util");
var graphics_1 = require("../../../util/graphics");
/** label text和line距离 4px */
var MARGIN = 4;
function antiCollision(labelGroups, labels, lineHeight, plotRange, center, isRight) {
    // adjust y position of labels to avoid overlapping
    var overlapping = true;
    var start = plotRange.start;
    var end = plotRange.end;
    var startY = Math.min(start.y, end.y);
    var totalHeight = Math.abs(start.y - end.y);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function (label) {
        if (label.y > maxY) {
            maxY = label.y;
        }
        if (label.y < minY) {
            minY = label.y;
        }
        return {
            size: lineHeight,
            targets: [label.y - startY],
            pos: null,
        };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
        totalHeight = maxY - startY;
    }
    while (overlapping) {
        /* eslint no-loop-func: 0 */
        boxes.forEach(function (box) {
            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
            // box.pos = Math.max(0, target - box.size / 2);
        });
        // detect overlapping and join boxes
        overlapping = false;
        i = boxes.length;
        while (i--) {
            if (i > 0) {
                var previousBox = boxes[i - 1];
                var box = boxes[i];
                if (previousBox.pos + previousBox.size > box.pos) {
                    // overlapping
                    previousBox.size += box.size;
                    previousBox.targets = previousBox.targets.concat(box.targets);
                    // overflow, shift up
                    if (previousBox.pos + previousBox.size > totalHeight) {
                        previousBox.pos = totalHeight - previousBox.size;
                    }
                    boxes.splice(i, 1); // removing box
                    overlapping = true;
                }
            }
        }
    }
    i = 0;
    // step 4: normalize y and adjust x
    boxes.forEach(function (b) {
        var posInCompositeBox = startY + lineHeight / 2; // middle of the label
        b.targets.forEach(function () {
            labels[i].y = b.pos + posInCompositeBox;
            posInCompositeBox += lineHeight;
            i++;
        });
    });
    // (x - cx)^2 + (y - cy)^2 = totalR^2
    labels.forEach(function (label) {
        var rPow2 = label.r * label.r;
        var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
        if (rPow2 < dyPow2) {
            label.x = center.x;
        }
        else {
            var dx = Math.sqrt(rPow2 - dyPow2);
            if (!isRight) {
                // left
                label.x = center.x - dx;
            }
            else {
                // right
                label.x = center.x + dx;
            }
        }
    });
    labels.forEach(function (label) {
        var labelGroup = util_1.find(labelGroups, function (group) { return group.get('id') === label.id; });
        var coordinate = labelGroup.get('coordinate');
        var coordRadius = coordinate.getRadius();
        if (labelGroup) {
            var labelShape = labelGroup.getChildren()[0];
            var labelLineShape = labelGroup.getChildren()[1];
            if (labelShape) {
                labelShape.attr('x', label.x);
                labelShape.attr('y', label.y);
            }
            if (labelLineShape) {
                var distance = label.offset;
                var angle = label.angle;
                // 贴近圆周
                var startPoint = graphics_1.polarToCartesian(center.x, center.y, angle, coordRadius);
                var inner = graphics_1.polarToCartesian(center.x, center.y, angle, coordRadius + distance / 2);
                var endPoint = {
                    x: label.x - Math.cos(angle) * MARGIN,
                    y: label.y - Math.sin(angle) * MARGIN,
                };
                labelLineShape.attr('path', ["M " + startPoint.x, startPoint.y + " Q" + inner.x, inner.y + " " + endPoint.x, endPoint.y].join(','));
            }
        }
    });
}
/**
 * pie outer-label: distribute algorithm
 */
function distribute(labels, shapes, items, region) {
    var offset = items[0] ? items[0].offset : 0;
    var lineHeight = items[0] ? util_1.get(items[0], 'labelHeight') : 14;
    var coordinate = labels[0] ? labels[0].get('coordinate') : null;
    if (coordinate && offset > 0) {
        // @ts-ignore
        var radius = coordinate.getRadius();
        var center_1 = coordinate.getCenter();
        var totalR = radius + offset;
        var totalHeight_1 = totalR * 2 + lineHeight * 2;
        var plotRange_1 = {
            start: coordinate.start,
            end: coordinate.end,
        };
        // step 1: separate labels
        var halves_1 = [
            [],
            [],
        ];
        items.forEach(function (labelItem) {
            if (!labelItem) {
                return;
            }
            if (labelItem.textAlign === 'right') {
                // left
                halves_1[0].push(labelItem);
            }
            else {
                // right or center will be put on the right side
                halves_1[1].push(labelItem);
            }
        });
        halves_1.forEach(function (half, index) {
            // step 2: reduce labels
            var maxLabelsCountForOneSide = Math.floor(totalHeight_1 / lineHeight);
            if (half.length > maxLabelsCountForOneSide) {
                half.sort(function (a, b) {
                    // sort by percentage DESC
                    return b['..percent'] - a['..percent'];
                });
                half.forEach(function (labelItem, idx) {
                    if (idx >= maxLabelsCountForOneSide) {
                        var id_1 = labelItem.id;
                        var label = util_1.find(labels, function (label) { return label.get('id') === id_1; });
                        label.remove(true); // 超出则不展示
                    }
                });
                // 同时移除
                half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
            }
            // step 3: distribute position (x and y)
            half.sort(function (a, b) {
                // sort by y ASC
                return a.y - b.y;
            });
            var labelShapes = util_1.map(half, function (labelItem) {
                var id = labelItem.id;
                return util_1.find(labels, function (label) { return label.get('id') === id; });
            });
            antiCollision(labelShapes, half, lineHeight, plotRange_1, center_1, index);
        });
    }
}
exports.distribute = distribute;
//# sourceMappingURL=distribute.js.map