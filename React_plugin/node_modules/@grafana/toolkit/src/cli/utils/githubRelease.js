"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var getPluginId_1 = require("../../config/utils/getPluginId");
var pluginValidation_1 = require("../../config/utils/pluginValidation");
var env_1 = require("../../plugins/env");
var path = require("path");
// @ts-ignore
var execa = require("execa");
var ghrPlatform = function () {
    switch (process.platform) {
        case 'win32':
            return 'windows';
        case 'darwin':
            return 'darwin';
        case 'linux':
            return 'linux';
        default:
            return process.platform;
    }
};
var GitHubRelease = /** @class */ (function () {
    function GitHubRelease(token, username, repository, releaseNotes, commitHash) {
        this.token = token;
        this.username = username;
        this.repository = repository;
        this.releaseNotes = releaseNotes;
        this.commitHash = commitHash;
    }
    /**
     * Get the ghr binary to perform the release
     */
    GitHubRelease.prototype.getGhr = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var GHR_VERSION, GHR_ARCH, GHR_PLATFORM, GHR_EXTENSION, outName, archiveName, exeName, exeNameFullPath, ghrUrl;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        GHR_VERSION = '0.13.0';
                        GHR_ARCH = process.arch === 'x64' ? 'amd64' : '386';
                        GHR_PLATFORM = ghrPlatform();
                        GHR_EXTENSION = process.platform === 'linux' ? 'tar.gz' : 'zip';
                        outName = "./ghr." + GHR_EXTENSION;
                        archiveName = "ghr_v" + GHR_VERSION + "_" + GHR_PLATFORM + "_" + GHR_ARCH;
                        exeName = process.platform === 'linux' ? 'ghr' : 'ghr.exe';
                        exeNameFullPath = path.resolve(process.cwd(), archiveName, exeName);
                        ghrUrl = "https://github.com/tcnksm/ghr/releases/download/v" + GHR_VERSION + "/" + archiveName + "." + GHR_EXTENSION;
                        return [4 /*yield*/, execa('wget', [ghrUrl, "--output-document=" + outName])];
                    case 1:
                        _a.sent();
                        if (!(GHR_EXTENSION === 'tar.gz')) return [3 /*break*/, 3];
                        return [4 /*yield*/, execa('tar', ['zxvf', outName])];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, execa('unzip', ['-p', outName])];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (!(process.platform === 'linux')) return [3 /*break*/, 7];
                        return [4 /*yield*/, execa('chmod', ['755', exeNameFullPath])];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [2 /*return*/, exeNameFullPath];
                }
            });
        });
    };
    GitHubRelease.prototype.release = function (recreate) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var ciDir, distDir, distContentDir, pluginJsonFile, pluginInfo, PUBLISH_DIR, commitHash, ghrExe, args, stdout;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        ciDir = env_1.getCiFolder();
                        distDir = path.resolve(ciDir, 'dist');
                        distContentDir = path.resolve(distDir, getPluginId_1.getPluginId());
                        pluginJsonFile = path.resolve(distContentDir, 'plugin.json');
                        pluginInfo = pluginValidation_1.getPluginJson(pluginJsonFile).info;
                        PUBLISH_DIR = path.resolve(env_1.getCiFolder(), 'packages');
                        commitHash = this.commitHash || ((_a = pluginInfo.build) === null || _a === void 0 ? void 0 : _a.hash);
                        return [4 /*yield*/, this.getGhr()];
                    case 1:
                        ghrExe = _b.sent();
                        if (!commitHash) {
                            throw 'The release plugin was not able to locate a commithash for release. Either build using the ci, or specify the commit hash with --commitHash <value>';
                        }
                        args = [
                            '-t',
                            this.token,
                            '-u',
                            this.username,
                            '-r',
                            this.repository,
                            '-c',
                            commitHash,
                            '-n',
                            this.repository + "_v" + pluginInfo.version,
                            '-b',
                            this.releaseNotes,
                            "v" + pluginInfo.version,
                            PUBLISH_DIR,
                        ];
                        if (recreate) {
                            args.splice(12, 0, '-recreate');
                        }
                        return [4 /*yield*/, execa(ghrExe, args)];
                    case 2:
                        stdout = (_b.sent()).stdout;
                        console.log(stdout);
                        return [2 /*return*/];
                }
            });
        });
    };
    return GitHubRelease;
}());
exports.GitHubRelease = GitHubRelease;
//# sourceMappingURL=githubRelease.js.map